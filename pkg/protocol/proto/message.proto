syntax = "proto3";
package pb;
option go_package = "GoChat/pkg/protocol/pb";

// 会话类型
enum SessionType {// 枚举聊天类型
  ST_UnKnow = 0;  // 未知
  ST_Single = 1; // 单聊
  ST_Group = 2;  // 群聊
}

// 用户所发送内容的消息类型
enum MessageType {// 枚举发送的消息类型
  MT_UnKnow = 0;  // 未知
  MT_Text = 1;  // 文本类型消息
  MT_Picture = 2;  // 图片类型消息
  MT_Voice = 3;  // 语音类型消息
}

// 所有 websocket 的消息类型
enum CmdType {// 枚举消息类型
  CT_UnKnow = 0;  // 未知
  CT_Login = 1;   // 连接注册，客户端向服务端发送，建立连接
  CT_Heartbeat = 2;  // 心跳，客户端向服务端发送，连接保活
  CT_Message = 3;  // 消息投递，可能是服务端发给客户端，也可能是客户端发给服务端
}

// 上行消息（客户端发送给服务端）顶层消息
// 使用：
// 客户端发送前：先组装出下层消息例如 HeartBeatMsg，序列化作为 Input 的 data 值，再填写 type 值，序列化 Input 发送给服务端
// 服务端收到后：反序列化成 Input，根据 type 值调用不同类型 handler，在 handler 中将 data 解析成其他例如 LoginMsg 类型消息，再做处理
message Input {
  CmdType type = 1;   // 消息类型，根据不同消息类型，可以将 data 解析成下面其他类型
  bytes data = 2;    // 数据
}

// 下行消息（服务端发送给客户端）顶层消息
// 使用：
// 服务端发送前：组装出下层消息例如 Message，序列化作为 Output 的 data 值，再填写其他值，序列化 Output 发送给客户端
// 客户端收到后：反序列化成 Output，根据 type 值调用不同类型 handler，在 handler 中将 data 解析成其他例如 Message 类型消息，再做处理
message Output {
  CmdType type = 1;  // 消息类型，根据不同的消息类型，可以将 data 解析成下面其他类型
  int32 code = 2;  // 错误码
  string CodeMsg = 3;  // 错误码信息
  bytes data = 4;  // 数据
}

// 登录
// 仅上行
message LoginMsg {
  uint64 user_id = 1;  // 用户id
  bytes token = 2;    // token
}

// 心跳
// 仅上行
message HeartBeatMsg {}

// 消息投递
// 上行、下行
message Message {
  SessionType session_type = 1;  // 会话类型 单聊、群聊
  uint64 receiver_id = 2;  // 接收者id 用户id/群组id
  uint64 sender_id = 3;  // 发送者id
  MessageType message_type = 4;  // 消息类型 文本、图片、语音
  bytes content = 5;  // 实际用户所发数据
}